<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
    />
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.5.21
    </script>
    <script>
      !(function () {
        var e = localStorage.getItem("dumi:prefers-color"),
          t = window.matchMedia("(prefers-color-scheme: dark)").matches,
          r = ["light", "dark", "auto"];
        document.documentElement.setAttribute(
          "data-prefers-color",
          e === r[2] ? (t ? r[1] : r[0]) : r.indexOf(e) > -1 ? e : r[0]
        );
      })();
    </script>
    <title>React项目性能分析及优化 - 前端面试手册</title>
  
</head>
  <body>
    <div id="root"><div class="__dumi-default-layout" data-route="/optimize/react/001" data-show-sidemenu="true" data-show-slugs="true" data-site-mode="true" data-gapless="false"><div class="__dumi-default-navbar" data-mode="site"><button class="__dumi-default-navbar-toggle"></button><a class="__dumi-default-navbar-logo" href="/">前端面试手册</a><nav><div class="__dumi-default-search"><input type="search" class="__dumi-default-search-input" value=""/><ul></ul></div><span><a href="/js">JavaScript</a></span><span><a href="/css">CSS</a></span><span><a href="/react">React</a></span><span><a href="/explorer">浏览器</a></span><span><a href="/network">网络</a></span><span><a href="/webpack">Webpack</a></span><span><a href="/node">Node</a></span><span><a href="/gof">设计模式</a></span><span><a href="/security">安全</a></span><span><a href="/algorithm">算法</a></span><span><a href="/skill">软技能</a></span><span><a href="/v8">V8</a></span><span><a aria-current="page" class="active" href="/optimize">性能优化</a></span><span><a href="/wiki">Wiki</a></span><div class="__dumi-default-navbar-tool"><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "></div></div></div></nav></div><div class="__dumi-default-menu" data-mode="site"><div class="__dumi-default-menu-inner"><div class="__dumi-default-menu-header"><a class="__dumi-default-menu-logo" href="/"></a><h1>前端面试手册</h1><p>前端面试手册</p></div><div class="__dumi-default-menu-mobile-area"><ul class="__dumi-default-menu-nav-list"><li><a href="/js">JavaScript</a></li><li><a href="/css">CSS</a></li><li><a href="/react">React</a></li><li><a href="/explorer">浏览器</a></li><li><a href="/network">网络</a></li><li><a href="/webpack">Webpack</a></li><li><a href="/node">Node</a></li><li><a href="/gof">设计模式</a></li><li><a href="/security">安全</a></li><li><a href="/algorithm">算法</a></li><li><a href="/skill">软技能</a></li><li><a href="/v8">V8</a></li><li><a aria-current="page" class="active" href="/optimize">性能优化</a></li><li><a href="/wiki">Wiki</a></li></ul><div class="__dumi-default-dark"><div class="__dumi-default-dark-switch "><button title="Dark theme" class="__dumi-default-dark-moon "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3854" width="22" height="22"><path d="M991.816611 674.909091a69.166545 69.166545 0 0 0-51.665455-23.272727 70.795636 70.795636 0 0 0-27.438545 5.585454A415.674182 415.674182 0 0 1 754.993338 698.181818c-209.594182 0-393.472-184.785455-393.472-395.636363 0-52.363636 38.539636-119.621818 69.515637-173.614546 4.887273-8.610909 9.634909-16.756364 14.103272-24.901818A69.818182 69.818182 0 0 0 384.631156 0a70.842182 70.842182 0 0 0-27.438545 5.585455C161.678429 90.298182 14.362065 307.898182 14.362065 512c0 282.298182 238.824727 512 532.38691 512a522.286545 522.286545 0 0 0 453.957818-268.334545A69.818182 69.818182 0 0 0 991.816611 674.909091zM546.679156 954.181818c-248.785455 0-462.941091-192-462.941091-442.181818 0-186.647273 140.637091-372.829091 300.939637-442.181818-36.817455 65.629091-92.578909 151.970909-92.578909 232.727273 0 250.181818 214.109091 465.454545 462.917818 465.454545a488.331636 488.331636 0 0 0 185.181091-46.545455 453.003636 453.003636 0 0 1-393.565091 232.727273z m103.656728-669.323636l-14.266182 83.781818a34.909091 34.909091 0 0 0 50.362182 36.770909l74.775272-39.563636 74.752 39.563636a36.142545 36.142545 0 0 0 16.174546 3.956364 34.909091 34.909091 0 0 0 34.210909-40.727273l-14.289455-83.781818 60.509091-59.345455a35.025455 35.025455 0 0 0-19.223272-59.578182l-83.61891-12.101818-37.376-76.101818a34.56 34.56 0 0 0-62.254545 0l-37.376 76.101818-83.618909 12.101818a34.909091 34.909091 0 0 0-19.246546 59.578182z m70.423272-64.698182a34.280727 34.280727 0 0 0 26.135273-19.083636l14.312727-29.090909 14.336 29.090909a34.257455 34.257455 0 0 0 26.135273 19.083636l32.046546 4.887273-23.272728 22.574545a35.234909 35.234909 0 0 0-10.007272 30.952727l5.46909 32.116364-28.625454-15.127273a34.490182 34.490182 0 0 0-32.302546 0l-28.695272 15.127273 5.469091-32.116364a35.141818 35.141818 0 0 0-9.984-30.952727l-23.272728-22.574545z" p-id="3855"></path></svg></button><button title="Light theme" class="__dumi-default-dark-sun "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4026" width="22" height="22"><path d="M915.2 476.16h-43.968c-24.704 0-44.736 16-44.736 35.84s20.032 35.904 44.736 35.904H915.2c24.768 0 44.8-16.064 44.8-35.904s-20.032-35.84-44.8-35.84zM512 265.6c-136.704 0-246.464 109.824-246.464 246.4 0 136.704 109.76 246.464 246.464 246.464S758.4 648.704 758.4 512c0-136.576-109.696-246.4-246.4-246.4z m0 425.6c-99.008 0-179.2-80.128-179.2-179.2 0-98.944 80.192-179.2 179.2-179.2S691.2 413.056 691.2 512c0 99.072-80.192 179.2-179.2 179.2zM197.44 512c0-19.84-19.136-35.84-43.904-35.84H108.8c-24.768 0-44.8 16-44.8 35.84s20.032 35.904 44.8 35.904h44.736c24.768 0 43.904-16.064 43.904-35.904zM512 198.464c19.776 0 35.84-20.032 35.84-44.8v-44.8C547.84 84.032 531.84 64 512 64s-35.904 20.032-35.904 44.8v44.8c0 24.768 16.128 44.864 35.904 44.864z m0 627.136c-19.776 0-35.904 20.032-35.904 44.8v44.736C476.096 940.032 492.16 960 512 960s35.84-20.032 35.84-44.8v-44.736c0-24.768-16.064-44.864-35.84-44.864z m329.92-592.832c17.472-17.536 20.288-43.072 6.4-57.024-14.016-14.016-39.488-11.2-57.024 6.336-4.736 4.864-26.496 26.496-31.36 31.36-17.472 17.472-20.288 43.008-6.336 57.024 13.952 14.016 39.488 11.2 57.024-6.336 4.8-4.864 26.496-26.56 31.296-31.36zM213.376 759.936c-4.864 4.8-26.56 26.624-31.36 31.36-17.472 17.472-20.288 42.944-6.4 56.96 14.016 13.952 39.552 11.2 57.024-6.336 4.8-4.736 26.56-26.496 31.36-31.36 17.472-17.472 20.288-43.008 6.336-56.96-14.016-13.952-39.552-11.072-56.96 6.336z m19.328-577.92c-17.536-17.536-43.008-20.352-57.024-6.336-14.08 14.016-11.136 39.488 6.336 57.024 4.864 4.864 26.496 26.56 31.36 31.424 17.536 17.408 43.008 20.288 56.96 6.336 14.016-14.016 11.264-39.488-6.336-57.024-4.736-4.864-26.496-26.56-31.296-31.424z m527.168 628.608c4.864 4.864 26.624 26.624 31.36 31.424 17.536 17.408 43.072 20.224 57.088 6.336 13.952-14.016 11.072-39.552-6.4-57.024-4.864-4.8-26.56-26.496-31.36-31.36-17.472-17.408-43.072-20.288-57.024-6.336-13.952 14.016-11.008 39.488 6.336 56.96z" p-id="4027"></path></svg></button><button title="Default to system" class="__dumi-default-dark-auto "><svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="11002" width="22" height="22"><path d="M127.658667 492.885333c0-51.882667 10.24-101.717333 30.378666-149.162666s47.786667-88.064 81.92-122.538667 75.093333-61.781333 122.538667-81.92 96.938667-30.378667 149.162667-30.378667 101.717333 10.24 149.162666 30.378667 88.405333 47.786667 122.88 81.92 61.781333 75.093333 81.92 122.538667 30.378667 96.938667 30.378667 149.162666-10.24 101.717333-30.378667 149.162667-47.786667 88.405333-81.92 122.88-75.093333 61.781333-122.88 81.92-97.28 30.378667-149.162666 30.378667-101.717333-10.24-149.162667-30.378667-88.064-47.786667-122.538667-81.92-61.781333-75.093333-81.92-122.88-30.378667-96.938667-30.378666-149.162667z m329.045333 0c0 130.048 13.994667 244.394667 41.984 343.381334h12.970667c46.762667 0 91.136-9.216 133.461333-27.306667s78.848-42.666667 109.568-73.386667 54.954667-67.242667 73.386667-109.568 27.306667-86.698667 27.306666-133.461333c0-46.421333-9.216-90.794667-27.306666-133.12s-42.666667-78.848-73.386667-109.568-67.242667-54.954667-109.568-73.386667-86.698667-27.306667-133.461333-27.306666h-11.605334c-28.672 123.562667-43.349333 237.909333-43.349333 343.722666z" p-id="11003"></path></svg></button></div></div></div><ul class="__dumi-default-menu-list"><li><a href="/optimize">性能优化目录</a></li><li><a target="_blank" rel="noopener noreferrer">性能优化基础</a><ul><li><a href="/optimize/basic/001"><span>前端性能优化 - 用RAIL模型分析性能</span></a></li><li><a href="/optimize/basic/002"><span>前端性能优化之白屏时间</span></a></li><li><a href="/optimize/basic/003"><span>大量图片加载优化</span></a></li></ul></li><li><a target="_blank" rel="noopener noreferrer">React性能优化</a><ul><li><a aria-current="page" class="active" href="/optimize/react/001"><span>React项目性能分析及优化</span></a></li></ul></li></ul></div></div><ul role="slug-list" class="__dumi-default-layout-toc"><li title="性能分析" data-depth="2"><a href="/optimize/react/001#性能分析"><span>性能分析</span></a></li><li title="Performance" data-depth="3"><a href="/optimize/react/001#performance"><span>Performance</span></a></li><li title="React Profiler" data-depth="3"><a href="/optimize/react/001#react-profiler"><span>React Profiler</span></a></li><li title="性能改进" data-depth="2"><a href="/optimize/react/001#性能改进"><span>性能改进</span></a></li><li title="PureComponent/ShouldComponentUpdate" data-depth="3"><a href="/optimize/react/001#purecomponentshouldcomponentupdate"><span>PureComponent/ShouldComponentUpdate</span></a></li><li title="React.memo" data-depth="3"><a href="/optimize/react/001#reactmemo"><span>React.memo</span></a></li><li title="善用 React.useMemo" data-depth="3"><a href="/optimize/react/001#善用-reactusememo"><span>善用 React.useMemo</span></a></li><li title="合理使用 React.useCallback" data-depth="3"><a href="/optimize/react/001#合理使用-reactusecallback"><span>合理使用 React.useCallback</span></a></li><li title="谨慎使用 Context" data-depth="3"><a href="/optimize/react/001#谨慎使用-context"><span>谨慎使用 Context</span></a></li><li title="小心使用 Redux" data-depth="3"><a href="/optimize/react/001#小心使用-redux"><span>小心使用 Redux</span></a></li><li title="总结" data-depth="2"><a href="/optimize/react/001#总结"><span>总结</span></a></li></ul><div class="__dumi-default-layout-content"><div class="markdown"><h1 id="react项目性能分析及优化"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#react项目性能分析及优化"><span class="icon icon-link"></span></a>React项目性能分析及优化</h1><h2 id="性能分析"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#性能分析"><span class="icon icon-link"></span></a>性能分析</h2><h3 id="performance"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#performance"><span class="icon icon-link"></span></a>Performance</h3><p>说到性能分析，当然要有一些指标，来度量现在网页“卡”的程度，并指导我们持续改进。chrome 自带的 Performance，一般就足够我们进行分析了。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-073841.png" alt="image.png"/></p><p>我写了一个简单的卡顿的例子，我们尝试通过 Performance 来分析出这个例子中哪一行代码卡。首先你可以打开这个<a target="_blank" rel="noopener noreferrer" href="https://h1e7f.sse.codesandbox.io/demo1">示例页面<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在这个页面的 input 框中输入的时候，你能明显感觉到非常卡顿。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-073905.gif" alt="2020-03-29 20.38.01.gif"/></p><p>从上面的动图可以看到，最后上面一栏出现很多红线，这就代表性能出问题了。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-074241.png" alt="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313538353530303634343338352d33623466393330352d643534302d343363642d623930372d3032343530653130373563312e706e673f782d6f73732d70726f636573733d696d616765"/></p><p>我们看下 Frames（帧） 这一栏，能看到红框中在一次输入中，776.9 ms 内都是 1 fps 的。这代表什么意思？我们知道正常网页刷新频率一般是 60 帧，也就是 16.67ms（1s/60）必须要刷新一次，否则就会有卡顿感，刷新时间越长，就越卡顿，在当前例子中，我们输入字符后，776.9 ms 后才触发更新，可以说是相当相当卡了。</p><p>我们知道 JS 是单线程的，也就是执行代码与绘制是同一个线程，必须等代码执行完，才能开始绘制。那具体是那一块代码执行时间长了呢？这里我们就要看 Main 这一栏，这一栏列出了 JS 调用栈。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-074349.png" alt="1"/></p><p>在 Main 这一栏中，可以看到我们的 KeyPress 事件执行了 771.03ms，然后往上托动，就能看到 KeyPress 中 JS 的执行栈，能找到每个函数的执行时间。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-074430.png" alt="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313538353530303637353138392d33303439346538302d633538652d346535622d383339632d6634386234343935376336352e706e673f782d6f73732d70726f636573733d696d616765"/></p><p>拖动到最下面，你可以看到 onChange 函数执行了很长时间，点击它，你可以在下面看到这个函数的具体信息，点击 <code>demo1.js:7</code> 甚至能看到每一行执行了多长时间。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-074535.png" alt="68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032302f706e672f3138393335302f313538353530303639333539322d33626461346338612d393163312d343336642d626664362d6262643437333630323735652e706e673f782d6f73732d70726f636573733d696d616765"/></p><p>罪魁祸首找到了，第九行代码执行了 630ms，找到问题所在，就好解决了。</p><p>这是一个最简单的例子，这种由单个地方引起的性能问题，也是比较好解决的。找到它、修改它、解决它！</p><h3 id="react-profiler"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#react-profiler"><span class="icon icon-link"></span></a>React Profiler</h3><p>React.Profiler 是 React 提供的，分析组件渲染次数、开始时间及耗时的一个 API，你可以在官网找到它的<a target="_blank" rel="noopener noreferrer" href="https://zh-hans.reactjs.org/docs/profiler.html">文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p><p>当然我们不需要每个组件都去加一个 React.Profiler 包裹，在开发环境下，React 会默记录每个组件的信息，我们可以通过 Chrome Profiler Tab 整体分析。</p><p>当然我们的 Chrome 需要安装 <a target="_blank" rel="noopener noreferrer" href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">React 扩展<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，才能在工具栏中找到 <code>Profiler</code> 的 Tab。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-075350.png" alt="2"/></p><p>Profiler 的用法和 Performance 用法差不多，点击开始记录，操作页面，然后停止记录，就会产出相关数据。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-075708.gif" alt="3"/></p><p>我找了一张比较复杂的图来做个示例，图中的数字分别表示：本次操作 React 做了 26 次 commit，第 14 次 commit 耗时最长，该次 commit 从 3.4s 时开始，消耗了 89.1 ms。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-075826.png" alt="4"/></p><p>同时我们切换到 Ranked 模式，可以看到该次 commit，每个组件的耗时排名。比如下图表示 <code>MarkdownText</code> 组件耗时最长，达到 13.7 ms。</p><p><img src="http://wuxiao-tech-doc.oss-cn-hangzhou.aliyuncs.com/2022-02-18-075929.png" alt="5"/></p><p>通过 React.Profiler，我们可以清晰的看到 React 组件的执行次数及时间，为我们优化性能指明了方向。</p><p>但我们需要注意的是，<strong>React.Profiler 记录的是 commit 阶段的数据</strong>。React 的执行分为两个阶段：</p><ul><li><strong>render</strong> 阶段：该阶段会确定例如 DOM 之类的数据需要做那些变化。在这个阶段，React 将会执行 render 及 render 之前的生命周期。</li><li><strong>commit</strong> 阶段：该阶段 React 会提交更新，同时在这个阶段，React 会执行像 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 之类的生命周期函数。</li></ul><p>所以 React.Profiler 的分析范围是有限的，比如我们最开始的 input 示例，通过 React Profiler 是分析不出来性能问题的。</p><h2 id="性能改进"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#性能改进"><span class="icon icon-link"></span></a>性能改进</h2><p>如果所有的性能问题都像上面这么简单就好了。某个点耗时极长，找到它并改进之，皆大欢喜。但在 React 项目中，最容易出现的问题是组件太多，每个组件执行 1ms，一百个组件就执行了 100ms，怎么优化？没有任何一个突出的点可以攻克，我们也不可能把一百个组件都优化成 0.01 ms。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">class</span><span class="token plain"> </span><span class="token class-name">App</span><span class="token plain"> extend </span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token property-access maybe-class-name">Component</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">super</span><span class="token punctuation">(</span><span class="token plain">props</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token property-access">state</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token plain"> </span><span class="token number">0</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token operator">&lt;</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token constant">A</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token constant">B</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token constant">C</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token constant">D</span><span class="token plain"> </span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token maybe-class-name">Button</span><span class="token plain"> onClick</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"> </span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token method function property-access">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token plain"> </span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token plain">click</span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token maybe-class-name">Button</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>就像上面这个组件一样，当我们点击 Button 更新 state 时，A/B/C/D 四个组件均会执行一次 render 计算，这些计算完全是无用的。当我们组件够多时，会逐渐成为性能瓶颈！我们目标是<strong>减少不必要的 render。</strong></p><h3 id="purecomponentshouldcomponentupdate"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#purecomponentshouldcomponentupdate"><span class="icon icon-link"></span></a>PureComponent/ShouldComponentUpdate</h3><p>说到避免 Render，当然第一时间想到的就是 ShouldComponentUpdate 这个生命周期，该生命周期通过判断 props 及 state 是否变化来手动控制是否需要执行 render。当然如果使用 PureComponent，组件会自动处理 ShouldComponentUpdate。</p><p>使用 PureComponent/ShouldComponentUpdate 时，需要注意几点：</p><ol><li>PureComponent 会对 props 与 state 做<strong>浅比较，*<em>所以一定要保证 props 与 state 中的数据是 immutable 的*</em>。</strong></li><li>如果你的数据不是 immutable 的，或许你可以自己手动通过 ShouldComponentUpdate 来进行深比较。当然深比较的性能一般都不好，不到万不得已，最好不要这样搞。</li></ol><h3 id="reactmemo"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#reactmemo"><span class="icon icon-link"></span></a>React.memo</h3><p>React.memo 与 PureComponent 一样，但它是为函数组件服务的。React.memo 会对 props 进行<strong>浅比较</strong>，如果一致，则不会再执行了。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const App = React.memo(()=&gt;{</span></div><div class="token-line"><span class="token plain">  return &lt;div&gt;&lt;/div&gt;</span></div><div class="token-line"><span class="token plain">});</span></div></pre></div><p>当然，如果你的数据不是 immutable 的，你可以通过 React.memo 的第二个参数来手动进行深比较，同样极其不推荐。</p><p>React.memo 对 props 的变化做了优化，避免了无用的 render。那 state 要怎么控制呢？</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const [state, setState] = useState(0);</span></div></pre></div><p>React 函数组件的 useState，其 setState 会自动做浅比较，也就是如果你在上面例子中调用了 <code>setState(0)</code> ，函数组件会忽略这次更新，并不会执行 render 的。一般在使用的时候要注意这一点，经常有同学掉进这个坑里面。</p><h3 id="善用-reactusememo"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#善用-reactusememo"><span class="icon icon-link"></span></a>善用 React.useMemo</h3><p>React.useMemo 是 React 内置 Hooks 之一，主要为了解决函数组件在频繁 render 时，无差别频繁触发无用的昂贵计算 ，一般会作为性能优化的手段之一。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function maybe-class-name">App</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">boolean</span><span class="token punctuation">,</span><span class="token plain"> setBoolean</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">start</span><span class="token punctuation">,</span><span class="token plain"> setStart</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span></div><div class="token-line"><span class="token plain">  </span><span class="token comment">// 这是一个非常耗时的计算</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> result </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">computeExpensiveFunc</span><span class="token punctuation">(</span><span class="token plain">start</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>在上面例子中， <code>computeExpensiveFunc</code> 是一个非常耗时的计算，但是当我们触发 <code>setBoolean</code> 时，组件会重新渲染， <code>computeExpensiveFunc</code> 会执行一次。这次执行是毫无意义的，因为 <code>computeExpensiveFunc</code> 的结果只与 <code>start</code> 有关系。</p><p>React.useMemo 就是为了解决这个问题诞生的，它可以指定只有当 <code>start</code> 变化时，才允许重新计算新的 <code>result</code> 。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> result </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token function">computeExpensiveFunc</span><span class="token punctuation">(</span><span class="token plain">start</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">start</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></pre></div><p>我建议 React.useMemo 要多用，能用就用，避免性能浪费。</p><h3 id="合理使用-reactusecallback"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#合理使用-reactusecallback"><span class="icon icon-link"></span></a>合理使用 React.useCallback</h3><p>在函数组件中，React.useCallback 也是性能优化的手段之一。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> </span><span class="token maybe-class-name">OtherComponent</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token maybe-class-name">React</span><span class="token punctuation">.</span><span class="token method function property-access">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token spread operator">...</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function maybe-class-name">App</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">boolan</span><span class="token punctuation">,</span><span class="token plain"> setBoolean</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token plain">value</span><span class="token punctuation">,</span><span class="token plain"> setValue</span><span class="token punctuation">]</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"> </span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function">onChange</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      axios</span><span class="token punctuation">.</span><span class="token method function property-access">post</span><span class="token punctuation">(</span><span class="token template-string template-punctuation string">`</span><span class="token template-string string">/api?v=</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation">v</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string string">&amp;state=</span><span class="token template-string interpolation interpolation-punctuation punctuation">${</span><span class="token template-string interpolation">state</span><span class="token template-string interpolation interpolation-punctuation punctuation">}</span><span class="token template-string template-punctuation string">`</span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"> </span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token punctuation">{</span><span class="token comment">/* OtherComponent 是一个非常昂贵的组件 */</span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token operator">&lt;</span><span class="token maybe-class-name">OtherComponent</span><span class="token plain"> onChange</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token plain">onChange</span><span class="token punctuation">}</span><span class="token operator">/</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>在上面的例子中， <code>OtherComponent</code> 是一个非常昂贵的组件，我们要避免无用的 render。虽然 <code>OtherComponent</code> 已经用 React.memo 包裹起来了，但在父组件每次触发 <code>setBoolean</code> 时， <code>OtherComponent</code> 仍会频繁 render。</p><p>因为父级组件 <code>onChange</code> 函数在每一次 render 时，都是新生成的，导致子组件浅比较失效。通过 React.useCallback，我们可以让 onChange 只有在 state 变化时，才重新生成。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const onChange = React.useCallback((v)=&gt;{</span></div><div class="token-line"><span class="token plain">  axios.post(`/api?v=${v}&amp;state=${state}`)</span></div><div class="token-line"><span class="token plain">}, [state])</span></div></pre></div><p>通过 useCallback 包裹后， <code>boolean</code> 的变化不会触发 <code>OtherComponent</code> ，只有 <code>state</code> 变化时，才会触发，可以避免很多无用的 <code>OtherComponent</code> 执行。</p><p>但是仔细想想， <code>state</code> 变化其实也是没有必要触发 <code>OtherComponent</code> 的，我们只要保证 <code>onChange</code> 一定能访问到最新的 <code>state</code> ，就可以避免 <code>state</code> 变化时，触发 <code>OtherComponent</code> 的 render。</p><div class="__dumi-default-code-block"><pre class="prism-code language-unknown"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token plain">const onChange = usePersistFn((v)=&gt;{</span></div><div class="token-line"><span class="token plain">  axios.post(`/api?v=${v}&amp;state=${state}`)</span></div><div class="token-line"><span class="token plain">})</span></div></pre></div><p>上面的例子，我们使用了 Umi Hooks 的 <a target="_blank" rel="noopener noreferrer" href="https://hooks.umijs.org/zh-CN/hooks/advanced/use-persist-fn">usePersistFn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它可以保证函数地址永远不会变化，无论何时， <code>onChange</code> 地址都不会变化，也就是无论何时， <code>OtherComponent</code> 都不会重新 render 了。</p><h3 id="谨慎使用-context"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#谨慎使用-context"><span class="icon icon-link"></span></a>谨慎使用 Context</h3><p>Context 是跨组件传值的一种方案，但我们需要知道，我们无法阻止 Context 触发的 render。</p><p>不像 props 和 state，React 提供了 API 进行浅比较，避免无用的 render，Context 完全没有任何方案可以避免无用的渲染。</p><p>有几点关于 Context 的建议：</p><ul><li>Context 只放置必要的，关键的，被大多数组件所共享的状态。</li><li>对非常昂贵的组件，建议在父级获取 Context 数据，通过 props 传递进来。</li></ul><h3 id="小心使用-redux"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#小心使用-redux"><span class="icon icon-link"></span></a>小心使用 Redux</h3><p>Redux 中的一些细节，稍不注意，就会触发无用的 render，或者其它的坑。</p><h4 id="精细化依赖"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#精细化依赖"><span class="icon icon-link"></span></a>精细化依赖</h4><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function maybe-class-name">App</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token punctuation">{</span><span class="token plain">props</span><span class="token punctuation">.</span><span class="token property-access">project</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword module">export</span><span class="token plain"> </span><span class="token keyword module">default</span><span class="token plain"> </span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token literal-property property">layout</span><span class="token operator">:</span><span class="token plain"> state</span><span class="token punctuation">.</span><span class="token property-access">layout</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token literal-property property">project</span><span class="token operator">:</span><span class="token plain"> state</span><span class="token punctuation">.</span><span class="token property-access">project</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token literal-property property">user</span><span class="token operator">:</span><span class="token plain"> state</span><span class="token punctuation">.</span><span class="token property-access">user</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">App</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></pre></div><p>在上面的例子中，App 组件显示声明依赖了 redux 的 <code>layout</code> 、 <code>project</code> 、 <code>user</code> 数据，在这三个数据变化时，都会触发 App 重新 render。</p><p>但是 App 只需要监听 <code>project.id</code> 的变化，所以精细化依赖可以避免无效的 render，是一种有效的优化手段。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> </span><span class="token function-variable function maybe-class-name">App</span><span class="token plain"> </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token punctuation">{</span><span class="token plain">props</span><span class="token punctuation">.</span><span class="token property-access">projectId</span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token operator">&lt;</span><span class="token operator">/</span><span class="token plain">div</span><span class="token operator">&gt;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">)</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword module">export</span><span class="token plain"> </span><span class="token keyword module">default</span><span class="token plain"> </span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token punctuation">)</span><span class="token arrow operator">=&gt;</span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token literal-property property">projectId</span><span class="token operator">:</span><span class="token plain"> state</span><span class="token punctuation">.</span><span class="token property-access">project</span><span class="token punctuation">.</span><span class="token property-access">id</span><span class="token punctuation">,</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token maybe-class-name">App</span><span class="token punctuation">)</span><span class="token punctuation">;</span></div></pre></div><h4 id="不可变数据"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#不可变数据"><span class="icon icon-link"></span></a>不可变数据</h4><p>我们经常会不小心直接操作 redux 源数据，导致意料之外的 BUG。</p><p>我们知道，JS 中的 数组/对象 是地址引用的。在下面的例子中，我们直接操作数组，并不会改变数据的地址。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">const</span><span class="token plain"> list </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token string">&#x27;1&#x27;</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">const</span><span class="token plain"> oldList </span><span class="token operator">=</span><span class="token plain"> list</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">list</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">&#x27;a&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain">list </span><span class="token operator">===</span><span class="token plain"> oldList</span><span class="token punctuation">;</span><span class="token plain"> </span><span class="token comment">//true</span></div></pre></div><p>在 Redux 中，就经常犯这样的错误。下面的例子，当触发 <code>PUSH</code> 后，直接修改了 <code>state.list</code> ，导致 <code>state.list</code> 的地址并没有变化。</p><div class="__dumi-default-code-block"><pre class="prism-code language-js"><button class="__dumi-default-icon __dumi-default-code-block-copy-btn" data-status="ready"></button><div class="token-line"><span class="token keyword">let</span><span class="token plain"> initState </span><span class="token operator">=</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token literal-property property">list</span><span class="token operator">:</span><span class="token plain"> </span><span class="token punctuation">[</span><span class="token string">&#x27;1&#x27;</span><span class="token punctuation">]</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">
</span></div><div class="token-line"><span class="token plain"></span><span class="token keyword">function</span><span class="token plain"> </span><span class="token function">counterReducer</span><span class="token punctuation">(</span><span class="token parameter">state</span><span class="token parameter punctuation">,</span><span class="token parameter"> action</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token keyword control-flow">switch</span><span class="token plain"> </span><span class="token punctuation">(</span><span class="token plain">action</span><span class="token punctuation">.</span><span class="token property-access">type</span><span class="token punctuation">)</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword">case</span><span class="token plain"> </span><span class="token string">&#x27;PUSH&#x27;</span><span class="token operator">:</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      state</span><span class="token punctuation">.</span><span class="token property-access">list</span><span class="token punctuation">.</span><span class="token method function property-access">push</span><span class="token punctuation">(</span><span class="token string">&#x27;2&#x27;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword control-flow">return</span><span class="token plain"> </span><span class="token punctuation">{</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">        </span><span class="token literal-property property">list</span><span class="token operator">:</span><span class="token plain"> state</span><span class="token punctuation">.</span><span class="token property-access">list</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">      </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">    </span><span class="token keyword module">default</span><span class="token operator">:</span><span class="token plain">    </span></div><div class="token-line"><span class="token plain">      </span><span class="token keyword control-flow">return</span><span class="token plain"> state</span><span class="token punctuation">;</span><span class="token plain"></span></div><div class="token-line"><span class="token plain">  </span><span class="token punctuation">}</span><span class="token plain"></span></div><div class="token-line"><span class="token plain"></span><span class="token punctuation">}</span></div></pre></div><p>如果组件中使用了 <code>ShouldComponentUpdate</code> 或者 <code>React.memo</code> ，浅比较 <code>props.list === nextProps.list</code> ，会阻止组件更新，导致意料之外的 BUG。</p><p>所以如果大量使用了 <code>ShouldComponentUpdate</code> 与 <code>React.memo</code> ，则一定要保证依赖数据的不可变性！建议使用 <a target="_blank" rel="noopener noreferrer" href="https://github.com/immerjs/immer">immer.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 来操作复杂数据。</p><h2 id="总结"><a aria-hidden="true" tabindex="-1" href="/optimize/react/001#总结"><span class="icon icon-link"></span></a>总结</h2><p>在项目初期，一定要考虑项目的复杂度，及早采取有效的措施，防止产生性能问题。如果在中后期才考虑性能问题，则难度会增加数十倍不止。</p></div><div class="__dumi-default-layout-footer-meta"><a target="_blank" rel="noopener noreferrer" href="https://github.com/weisuoke/fe-interview-guidebook/edit/master/docs/optimize/react/001.md">Edit this doc on GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="__dumi-default-external-link-icon"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><span data-updated-text="Last update: ">3/6/2022 15:43:57</span></div></div></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="/umi.js"></script>
    <script src="/docs__optimize__react__001.md.js"></script>
  </body>
</html>
